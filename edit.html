<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        #editor{background-color: bisque;height: 400px;margin: 50px; padding:10px;}
        #editor p{line-height: 1.7;}
    </style>

</head>
<body>
<div id="editor">
    <p><br></p>
</div>

<script>
    /**
     * 시작 요소인가?
     * 부모요소중에 동일한 요소가 있는가? 부모요소에 중복되는 요소가 있을 경우 요소를 덮지 않는다
     * 자식요소중 동일한 요소가 있는가? 자식 요소중에 중복되는 요소가 있을 경우 중복되는 자식요소 위치에 자식요소에 자식요소들을 치환한다.
     * 종료 요소인가?
     */

    const startObj = {};
    const endObj = {};
    let childNodes = [];
    let scopeObjects = [];
    let scopeParants = [];
    let scopeParantTagNames = [];
    let editorTarget;
    let loopStartCheck = false;
    let loopEndCheck = false;

    function init(target){
        editorTarget = document.getElementById( target );
        document.getElementById( target ).setAttribute( 'contenteditable', 'true' )
        document.getElementById( target ).setAttribute( 'onclick', 'focusEditor(this);' )
    }

    function focusEditor(obj){
        //addRange

        console.log(window.getSelection().focusNode);
       // childNodes = getNodeList(window.getSelection().getRangeAt(0).commonAncestorContainer.childNodes);

    }

    function findChildReturnObj(target, findObj){
        if( isSame(target, findObj) ){
            return target;
        }else{
            for(let i=0;target && i<target.childNodes.length;i++){
                const child = target.childNodes[i];
                let result = findChildReturnObj(child, findObj);

                if( result ){
                    return result;
                }
            }
        }
    }

    function setParents(target, callCnt) {
        callCnt = (callCnt || 0);
        if( callCnt == 0 ){
            scopeParants = [];
            scopeParantTagNames = [];
        }

        if (!isSame(target.parentNode, editorTarget)) {
            scopeParants.push(target.parentNode)
            scopeParantTagNames.push(target.parentNode.tagName)

            setParents(target.parentNode, (++callCnt));
        }
    }

    function getParents(){
        return scopeParants;
    }

    function getParentTagNames(){
        return scopeParantTagNames;
    }

    function setTargetObj(nodes){
        for(let i=0;i<nodes.length;i++){
            const node = nodes[i];
            scopeObjects.push(node);
        }
    }

    function getTargetObj(){
        return scopeObjects;
    }

    function getRangeNodes(){
        if( window.getSelection().type == 'None'){
            return;
        }

        startObj.container = window.getSelection().getRangeAt(0).startContainer;
        startObj.offset = window.getSelection().getRangeAt(0).startOffset;
        endObj.container = window.getSelection().getRangeAt(0).endContainer;
        endObj.offset = window.getSelection().getRangeAt(0).endOffset;

        if( window.getSelection().getRangeAt(0).commonAncestorContainer.childNodes.length == 0 ){
            return [window.getSelection().getRangeAt(0).commonAncestorContainer];
        }
        window.getSelection().focusNode

        //addRange
       // if()

        childNodes = getNodeList(window.getSelection().getRangeAt(0).commonAncestorContainer.childNodes);
        return childNodes;
    }

    function isSame(original, target){
        return original === target;
    }

    function copyObj(target, deep){
        return target.cloneNode(deep || true);
    }

    function addRange(startObj, startOffSet, endObj, endOffSet){
        let range = new Range();

        range.setStart(startObj, startOffSet);
        range.setEnd(endObj, endOffSet);

        // apply the selection, explained later below
        document.getSelection().removeAllRanges();
        document.getSelection().addRange(range);
    }

    function mergeChildNodesBefore(target, nodes){
        let copyNodes = [];
        nodes.forEach(function(obj){
            copyNodes.push(obj);
        })

        let refChild;
        copyNodes.forEach(function(obj,idx){
            if(idx==0){
                refChild = obj;
                target.firstChild.before(obj);
            }else{
                refChild.after(obj);
                refChild = obj;
            }
        })
    }

    function mergeChildNodesAfter(target, nodes){
        let copyNodes = getNodeList(nodes);

        copyNodes.forEach(function(obj,idx){
            target.appendChild(obj)
        })
    }

    function putPrevElementInMyElement(target){
        const previousElement = target.previousElementSibling;
        mergeChildNodesBefore(target, previousElement.childNodes);
        previousElement.remove();
    }

    function putNextElementInMyElement(target){
        const nextElement = target.nextElementSibling;
        mergeChildNodesAfter(target, nextElement.childNodes);
        nextElement.remove();
    }

    function mergeSameElements(targetTag){
        if( targetTag.previousSibling && targetTag.previousSibling.tagName === targetTag.tagName ){
            // 노드 앞에 동일한 태그가 있을 경우 앞에 있는 노드에 append 처리
            putPrevElementInMyElement(targetTag);
        }else if( targetTag.nextSibling && targetTag.nextSibling.tagName === targetTag.tagName ){
            // 노드 뒤에 동일한 태그가 있을 경우 뒤에 있는 노드에 prepend 처리
            putNextElementInMyElement(targetTag);
        }
    }

    function changeLocation(target,chanObj){
        const targetTag = typeof(target) === 'string' ? document.createElement( target ) : target;
        const copySelEle = copyObj(chanObj);

        if(chanObj === startObj.container){
            startObj.container = copySelEle;
        }

        if(chanObj === endObj.container){
            endObj.container = copySelEle;
        }

        targetTag.appendChild(copySelEle);
        replace(targetTag, chanObj);
    }

    function getTextNode(text){
        return document.createTextNode(text);
    }

    function replace(target, replaceObj){
        replaceObj.parentNode.replaceChild(target, replaceObj);
    }

    function resetStartContainer(obj, offset){
        startObj.container = obj;
        startObj.offset = offset;
    }

    function resetEndContainer(obj, offset){
        endObj.container = obj;
        endObj.offset = offset;
    }

    function getNodeList(nodes){
        let copyNodes = [];
        nodes.forEach(function(obj){
            copyNodes.push(obj);
        })

        return copyNodes;
    }

    function cover(target, rangeNodes) {
        target = target.toUpperCase();
        const selectedEles = rangeNodes?rangeNodes:getRangeNodes();

        if (!selectedEles || selectedEles.length == 0) {
            return;
        }

        if( !rangeNodes ){
            loopStartCheck = false;
            loopEndCheck = false;
        }

        for (let i = 0; i < selectedEles.length; i++) {

            if( selectedEles[i].tagName == 'P' ){
                cover(target, selectedEles[i].childNodes);
                continue;
            }

            if (loopEndCheck) break;
            let sObj = findChildReturnObj(selectedEles[i], startObj.container);
            let eObj = findChildReturnObj(selectedEles[i], endObj.container);
            const targetTag = document.createElement(target);

            if (sObj) loopStartCheck = true;
            if (eObj) loopEndCheck = true;

            // 부모객체에 target과 동일한 태그가 있을 경우 로직 종료
            setParents(sObj || eObj || selectedEles[i])
            if (getParentTagNames().indexOf(target) > -1) {
                continue;
            }

            if (sObj && eObj) {
                if (sObj.nodeName == '#text') {
                    let appendList = [];
                    let textNode = getTextNode(sObj.substringData(startObj.offset, endObj.offset - startObj.offset));
                    targetTag.appendChild(textNode);

                    appendList.push(getTextNode(sObj.substringData(0, startObj.offset)));
                    appendList.push(targetTag);
                    appendList.push(getTextNode(eObj.substringData(endObj.offset, eObj.length)));

                    let refChild;
                    appendList.forEach(function (obj, idx) {
                        if (idx == 0) {
                            refChild = obj;
                            sObj.after(obj);
                        } else {
                            refChild.after(obj);
                            refChild = obj;
                        }
                    })

                    resetStartContainer(textNode, 0);
                    resetEndContainer(textNode, textNode.length);
                    sObj.remove();
                }
            } else if (sObj) {
                if (sObj.nodeName == '#text') {
                    let textNode = getTextNode(sObj.substringData(startObj.offset, sObj.length))

                    sObj.before(getTextNode(sObj.substringData(0, startObj.offset)))
                    targetTag.appendChild(textNode);
                    resetStartContainer(textNode, 0);
                }

                replace(targetTag, sObj);
            } else if (eObj) {
                if (eObj.nodeName == '#text') {
                    let textNode = getTextNode(eObj.substringData(0, endObj.offset))

                    eObj.after(getTextNode(eObj.substringData(endObj.offset, eObj.length)));
                    targetTag.appendChild(textNode);
                    resetEndContainer(textNode, textNode.length);
                }

                replace(targetTag, eObj);
            } else if (loopStartCheck) {
                changeLocation(targetTag, selectedEles[i]);
            }
        }

        if( scopeParants.length > 0 ){
            const nodes = getNodeList(scopeParants[scopeParants.length - 1].childNodes);
            nodes.forEach(function (obj) {
                mergeSameElements(obj);
            })
        }

        addRange(
            startObj.container,
            startObj.offset,
            endObj.container,
            endObj.offset
        );
    }

    init('editor');
</script>

</body>
</html>
