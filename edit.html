<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        #editor{background-color: bisque;height: 400px;margin: 50px;}
    </style>

</head>
<body>
<div id="editor">
    <p>as<b><i>ad</i>sfd<u>sgd</u></b><i>s</i>fdsf<b>dsfd</b>asfdsfds</p>
    <p><br></p>
</div>

<script>
    const startObj = {};
    const endObj = {};
    let childNodes = [];
    let scopeObjects = [];
    let scopeParants = [];
    let scopeParantTagNames = [];
    let editorTarget;

    function init(target){
        editorTarget = document.getElementById( target );
        document.getElementById( target ).setAttribute( 'contenteditable', 'true' )
    }

    function findReturnObj(target, findObj){
        if( isSame(target, findObj) ){
            return target;
        }else{
            for(let i=0;target && i<target.childNodes.length;i++){
                const child = target.childNodes[i];
                let result = findReturnObj(child, findObj);

                if( result ){
                    return result;
                }
            }
        }
    }

    function setParents(target, callCnt) {
        callCnt = (callCnt || 0);
        if( callCnt == 0 ){
            scopeParants = [];
            scopeParantTagNames = [];
        }

        if (!isSame(target.parentNode, editorTarget)) {
            scopeParants.push(target.parentNode)
            scopeParantTagNames.push(target.parentNode.tagName)

            setParents(target.parentNode, (++callCnt));
        }
    }

    function getParents(){
        return scopeParants;
    }

    function getParentTagNames(){
        return scopeParantTagNames;
    }

    function setTargetObj(nodes){
        for(let i=0;i<nodes.length;i++){
            const node = nodes[i];
            scopeObjects.push(node);
        }
    }

    function getTargetObj(){
        return scopeObjects;
    }

    function getRangeNodes(){
        if( window.getSelection().type == 'None'){
            return;
        }

        startObj.container = window.getSelection().getRangeAt(0).startContainer;
        startObj.offset = window.getSelection().getRangeAt(0).startOffset;
        endObj.container = window.getSelection().getRangeAt(0).endContainer;
        endObj.offset = window.getSelection().getRangeAt(0).endOffset;

        if( window.getSelection().getRangeAt(0).commonAncestorContainer.childNodes.length == 0 ){
            return [window.getSelection().getRangeAt(0).commonAncestorContainer];
        }

        childNodes = window.getSelection().getRangeAt(0).commonAncestorContainer.childNodes;
        return window.getSelection().getRangeAt(0).commonAncestorContainer.childNodes;
    }

    function isSame(original, target){
        return original === target;
    }

    function copyObj(target, deep){
        return target.cloneNode(deep || true);
    }

    function addRange(startObj, startOffSet, endObj, endOffSet){
        let range = new Range();

        range.setStart(startObj, startOffSet);
        range.setEnd(endObj, endOffSet);

        // apply the selection, explained later below
        document.getSelection().removeAllRanges();
        document.getSelection().addRange(range);
    }

    function mergeChildNodesBefore(target, nodes){
        let copyNodes = [];
        nodes.forEach(function(obj){
            copyNodes.push(obj);
        })

        let refChild;
        copyNodes.forEach(function(obj,idx){
            if(idx==0){
                refChild = obj;
                target.firstChild.before(obj);
            }else{
                refChild.after(obj);
                refChild = obj;
            }
        })
    }

    function mergeChildNodesAfter(target, nodes){
        let copyNodes = getNodeList(nodes);

        copyNodes.forEach(function(obj,idx){
            target.appendChild(obj)
        })
    }

    function putPrevElementInMyElement(target){
        const previousElement = target.previousElementSibling;
        mergeChildNodesBefore(target, previousElement.childNodes);
        previousElement.remove();
    }

    function putNextElementInMyElement(target){
        const nextElement = target.nextElementSibling;
        mergeChildNodesAfter(target, nextElement.childNodes);
        nextElement.remove();
    }

    function mergeSameElements(targetTag){
        if( targetTag.previousSibling && targetTag.previousSibling.tagName === targetTag.tagName ){
            // 노드 앞에 동일한 태그가 있을 경우 앞에 있는 노드에 append 처리
            putPrevElementInMyElement(targetTag);
        }else if( targetTag.nextSibling && targetTag.nextSibling.tagName === targetTag.tagName ){
            // 노드 뒤에 동일한 태그가 있을 경우 뒤에 있는 노드에 prepend 처리
            putNextElementInMyElement(targetTag);
        }
    }

    function changeLocation(target,chanObj){
        const targetTag = typeof(target) === 'string' ? document.createElement( target ) : target;
        const copySelEle = copyObj(chanObj);

        if(chanObj === startObj.container){
            startObj.container = copySelEle;
        }

        if(chanObj === endObj.container){
            endObj.container = copySelEle;
        }

        targetTag.appendChild(copySelEle);
        replace(targetTag, chanObj);
    }

    function getTextNode(text){
        return document.createTextNode(text);
    }

    function replace(target, replaceObj){
        replaceObj.parentNode.replaceChild(target, replaceObj);
    }

    function resetStartContainer(obj, offset){
        startObj.container = obj;
        startObj.offset = offset;
    }

    function resetEndContainer(obj, offset){
        endObj.container = obj;
        endObj.offset = offset;
    }

    function getNodeList(nodes){
        let copyNodes = [];
        nodes.forEach(function(obj){
            copyNodes.push(obj);
        })

        return copyNodes;
    }

    function cover(target){
        target = target.toUpperCase();
        const selectedEles = getRangeNodes();

        if( !selectedEles || selectedEles.length == 0 ){
            return;
        }

        let startCheck = false;
        let endCheck = false;
        for(let i=0;i<selectedEles.length;i++){
            if( endCheck )break;
            let sObj = findReturnObj(selectedEles[i], startObj.container);
            let eObj = findReturnObj(selectedEles[i], endObj.container);
            const targetTag = document.createElement( target );

            if( sObj ) startCheck = true;
            if( eObj ) endCheck = true;


            // 부모객체에 target과 동일한 태그가 있을 경우 로직 종료
            setParents(sObj || eObj || selectedEles[i])
            if( getParentTagNames().indexOf(target) > -1 ){
                continue;
            }

            if( sObj && eObj ){
                if( sObj.nodeName == '#text'){
                    let appendList = [];
                    let textNode = getTextNode(sObj.substringData(startObj.offset, endObj.offset-startObj.offset));
                    targetTag.appendChild(textNode);

                    appendList.push(getTextNode(sObj.substringData(0,startObj.offset)));
                    appendList.push(targetTag);
                    appendList.push(getTextNode(eObj.substringData(endObj.offset,eObj.length)));

                    let refChild;
                    appendList.forEach(function(obj,idx){
                        if(idx==0){
                            refChild = obj;
                            sObj.after(obj);
                        }else{
                            refChild.after(obj);
                            refChild = obj;
                        }
                    })

                    resetStartContainer(textNode, 0);
                    resetEndContainer(textNode, textNode.length);
                    sObj.remove();
                }
            }else if( sObj ){
                if( sObj.nodeName == '#text'){
                    let textNode = getTextNode(sObj.substringData(startObj.offset, sObj.length))

                    sObj.before(getTextNode(sObj.substringData(0,startObj.offset)))
                    targetTag.appendChild(textNode);
                    resetStartContainer(textNode, 0);
                }

                replace(targetTag, sObj);
            }else if(eObj){
                if( eObj.nodeName == '#text'){
                    let textNode = getTextNode(eObj.substringData(0,endObj.offset))

                    eObj.after(getTextNode(eObj.substringData(endObj.offset, eObj.length)));
                    targetTag.appendChild(textNode);
                    resetEndContainer(textNode, textNode.length);
                }

                replace(targetTag, eObj);
            }else if( startCheck ){
                changeLocation(targetTag, selectedEles[i]);
            }

        }

        const nodes = getNodeList(scopeParants[scopeParants.length-1].childNodes);

        debugger;
        nodes.forEach(function(obj){
            mergeSameElements(obj);
        })

        addRange(
            startObj.container,
            startObj.offset,
            endObj.container,
            endObj.offset
        );
    }

    init('editor');
</script>

</body>
</html>
